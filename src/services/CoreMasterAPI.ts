import axios, { AxiosInstance, AxiosRequestConfig } from "axios";

//################################################################################
//## TYPE DEFINITIONS (Generated from OpenAPI Schemas)
//################################################################################

/**
 * Common error response format based on RFC 8707.
 */
export interface ErrorProblemDetails {
  /**
   * A URI reference [RFC3986] that identifies the problem type.
   * @example "https://example.com/probs/out-of-credit"
   */
  type?: string;
  /**
   * A short, human-readable summary of the problem type.
   * @example "You do not have enough credit."
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @example 400
   */
  status: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @example "Your current balance is 30, but that costs 50."
   */
  detail?: string;
  /**
   * A code that identifies the problem type.
   * @example "invalid_request"
   */
  error_code: string;
  /**
   * An array of individual error details if the problem has multiple causes.
   */
  errors?:
    | {
        /**
         * A code that identifies the problem type.
         */
        error_code: string;
        /**
         * A human-readable explanation specific to this occurrence of the problem.
         */
        detail?: string;
      }[]
    | null;
}

/**
 * Represents the type of an agreement.
 */
export interface AgreementType {
  agreementTypeId: string; // uuid, readOnly
  /**
   * Unique code representing the transaction relationship. Logical key.
   */
  agreementTypeCode: string; // readOnly
  /**
   * true: enabled, false: disabled
   */
  isActive: boolean;
  attributes: {
    /**
     * System-defined version to manage changes to attribute values.
     */
    _ver: string;
    /**
     * Name. For an organization, etc., it would be the official name.
     */
    name: string;
    /**
     * Abbreviated name (optional).
     */
    abbrevName?: string;
    /**
     * Description text (optional).
     */
    description?: string;
    /**
     * Generally, related duties on the buyer's side. If not specified, all are targeted. AND condition with roles. Usable at contact time.
     */
    firstPartyRelatedDuties?: string[];
    /**
     * Generally, related roles on the buyer's side. If not specified, all are targeted. AND condition with duties. Usable at contact time.
     */
    firstPartyRelatedRoles?: string[];
    /**
     * Generally, for the supplier side. If not specified, all are targeted. AND condition with roles. Usable at contact time.
     */
    secondPartyRelatedDuties?: string[];
    /**
     * Generally, for the supplier side. If not specified, all are targeted. AND condition with duties. Usable at contact time.
     */
    secondPartyRelatedRoles?: string[];
  };
  version?: number;
}

/**
 * Placeholder for the main Agreement schema, as it was referenced but not fully defined.
 * Properties are inferred from usage in request bodies and other parts of the spec.
 */
export interface Agreement {
  agreementId?: string; // uuid, readOnly
  agreementTypeId?: string; // uuid, readOnly
  firstPartyUnitSetId?: string; // uuid, readOnly
  firstPartyUnitId?: string; // uuid, readOnly on update
  secondPartyUnitSetId?: string; // uuid, readOnly
  secondPartyUnitId?: string; // uuid, readOnly on update
  attributes?: {
    _ver?: number;
    priorAgreementId?: string; // uuid, readOnly
    agreementRevision?: number; // readOnly
    name?: string; // readOnly
    description?: string;
    firstPartySigner?: string; // readOnly
    firstPartyRelevantUnitList?: string[]; // uuid[]
    secondPartySigner?: string; // readOnly
    secondPartyRelevantUnitList?: string[]; // uuid[]
    agreedDate?: string; // date-time, readOnly
    referenceAgreementIdList?: string[]; // uuid[], readOnly on update
  };
  effectiveStartDate?: string; // date-time, readOnly
  effectiveEndDate?: string; // date-time, readOnly
  cancellationDate?: string; // date-time, readOnly
  version?: number; // readOnly on update
}

/**
 * Schema for a Job Duty.
 */
export interface JobDuty {
  jobDutyId?: string; // uuid, readOnly
  unitSetId?: string; // uuid
  jobDutyCode: string;
  roleSetIdList?: string[]; // uuid[]
  effectiveStartDate: string; // date-time
  effectiveEndDate: string; // date-time
  targetUnitId?: string; // uuid, readOnly on update
  attributes: {
    _ver?: string;
    name: string;
    abbrevName?: string;
    description?: string;
  };
  ownerUnitId?: string; // uuid
  ownerUserId?: string; // uuid
  ownerScopeType?: string;
  scopeType?: string;
  scopeId?: string; // uuid
  aclId?: string; // uuid
}

/**
 * Schema for a Role Set.
 */
export interface RoleSet {
  roleSetId?: string; // uuid, readOnly
  attributes?: {
    name: string;
    abbrevName?: string;
    description?: string;
  };
  roleCodeList: string[];
  targetUnitId?: string; // uuid
  ownerUnitId?: string; // uuid
  ownerUserId?: string; // uuid
  ownerScopeType?: ("unitSet" | "unit" | "user") | null;
  scopeType?: ("everyone" | "unitSet" | "unit" | "user") | null;
  scopeId?: string; // uuid
  aclId?: string; // uuid
}

/**
 * Schema for a single Role.
 */
export interface Role {
  roleCode: string;
  parentRoleCode?: string | null;
  attributes?: {
    _ver: string;
    name?: string;
    description?: string;
  };
}

// Types for `listBusinessPartyUsers` endpoint
export interface ListBusinessPartyUsersScope {
  scopeType: "UnitSet" | "UnitTree" | "AgreementType";
  scopeId: string; // uuid
  roleCode?: string;
  jobDutyCode?: string;
  filters?: {
    filterType: string;
    filterValue: string[];
  }[];
}

export interface BusinessPartyUserRecord {
  userId?: string; // uuid
  userCode?: string;
  userName?: string;
  unitJobDutyList?: {
    assignedName?: string;
    roleCode?: string;
    unitId?: string; // uuid
    unitCode?: string;
    unitName?: string;
    unitAbsPathCode?: {
      id?: string; // uuid
      code?: string;
      name?: string;
    };
  }[];
}

export interface ListBusinessPartyUsersResponse {
  hasNext?: boolean;
  records?: BusinessPartyUserRecord[];
}

// Types for `list-business-partners` endpoint
export interface SearchCondition {
  scopeType: "UnitSet" | "UnitTree" | "AgreementType";
  scopeId: string; // uuid
  filters?: {
    filterType: string;
    filterValue: string[];
  }[];
}

export interface ListBusinessPartnersBody {
  searchConditions: SearchCondition[];
  groupUnitLimit?: number;
  groupUserLimit?: number;
  limit?: number;
}

export interface BusinessPartnerUser {
  userId?: string; // uuid
  userCode?: string;
  roleCode?: string;
  name?: string;
  abbrevName?: string;
  email?: string;
}

export interface BusinessPartnerUnit {
  unitId?: string; // uuid
  unitCode?: string;
  name?: string;
  abbrevName?: string;
  hasNextUser?: boolean;
  unitAbsPathCode?: {
    id?: string; // uuid
    code?: string;
    name?: string;
    abbrevName?: string;
  };
  userList?: BusinessPartnerUser[];
}

export interface BusinessPartnerRecord {
  agreementTypeId?: string; // uuid
  agreementTypeCode?: string;
  name?: string;
  abbrevName?: string;
  hasNextUnit?: boolean;
  hasNextUser?: boolean;
  unitList?: BusinessPartnerUnit[];
}

export interface ListBusinessPartnersResponse {
  hasNext?: boolean;
  hasNextAgreementType?: boolean;
  hasNextUnit?: boolean;
  hasNextUser?: boolean;
  records?: BusinessPartnerRecord[];
}

// Types for `get-objects-by-id` endpoint
export interface GetObjectsByIdBody {
  /**
   * Array of user IDs to retrieve. Max: 1000 items.
   */
  userIds?: string[];
  /**
   * Array of unit IDs to retrieve. Max: 1000 items.
   */
  unitIds?: string[];
  /**
   * Whether to consider the effective period. Default: false.
   */
  activeOnly?: boolean;
}

export interface UserInfo {
  userId: string;
  userCode: string;
  attributes: { [key: string]: any };
  effectiveStartDate: string;
  effectiveEndDate: string;
}

export interface UnitInfo {
  unitId: string;
  unitCode: string;
  attributes: { [key: string]: any };
  effectiveStartDate: string;
  effectiveEndDate: string;
  unitAbsPathCode: {
    id: string;
    code: string;
    name: string;
    abbrevName: string;
  }[];
}

export interface ObjectError {
  userId?: string;
  unitId?: string;
  errorCode: string;
  message: string;
}

export interface GetObjectsByIdResponse {
  users: (UserInfo | ObjectError)[];
  units: (UnitInfo | ObjectError)[];
}

//################################################################################
//## API CLIENT CLASS
//################################################################################

export class ApiClient {
  private axiosInstance: AxiosInstance;

  constructor(baseURL: string, axiosInstance?: AxiosInstance) {
    this.axiosInstance =
      axiosInstance ||
      axios.create({
        baseURL,
        headers: {
          "Content-Type": "application/json",
        },
      });
  }

  /**
   * Set the authentication token for all subsequent requests.
   * @param token The A2B access token.
   */
  public setAuthToken(token: string) {
    this.axiosInstance.defaults.headers.common["X-A2b-Token"] = token;
  }

  //==============================================================================
  //== Agreements Service
  //==============================================================================

  /**
   * Register an agreement.
   * Creates an agreement of the specified agreementType. Returns an error if a combination of Type, unitSet, and Unit for 1st/2nd party already exists.
   * @param requestBody The agreement object to create.
   * @returns The created agreement data.
   */
  public async createAgreement(
    requestBody: Agreement,
    config?: AxiosRequestConfig
  ): Promise<{ status?: number; data?: Agreement }> {
    const response = await this.axiosInstance.post(
      "/agreements/",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Get a list of agreements.
   * Returns a list of agreements that match the specified criteria and implicit conditions.
   * @param params Query parameters for filtering and pagination.
   * @param params.typeCode Filter by type code.
   * @param params.dutyCode Filter by duty code.
   * @param params.roleCode Filter by role code.
   * @param params.unitSetId For superusers. Normally, the unitSetId from the token is used.
   * @param params.targetDate Get information at a specific point in time.
   * @param params.offset Start position for data retrieval.
   * @param params.limit Number of items to retrieve in a single request.
   * @returns A list of agreements.
   */
  public async listAgreements(
    params?: {
      typeCode?: string;
      dutyCode?: string;
      roleCode?: string;
      unitSetId?: string;
      targetDate?: string;
      offset?: number;
      limit?: number;
    },
    config?: AxiosRequestConfig
  ): Promise<{
    status?: number;
    data?: { count?: number; records?: Agreement[] };
  }> {
    const response = await this.axiosInstance.get("/agreements/list", {
      ...config,
      params,
    });
    return response.data;
  }

  /**
   * Retrieve an agreement.
   * Returns detailed information for a specified agreement.
   * @param agreementId The ID of the agreement to retrieve.
   * @returns Detailed information of the agreement.
   */
  public async getAgreement(
    agreementId: string,
    config?: AxiosRequestConfig
  ): Promise<{ status?: number; data?: Agreement }> {
    const response = await this.axiosInstance.get(
      `/agreements/${agreementId}`,
      config
    );
    return response.data;
  }

  /**
   * Update an agreement.
   * Performs a partial update (like PATCH) on the specified attributes group. agreement_id and agreement_type related fields cannot be updated.
   * @param agreementId The ID of the agreement to update.
   * @param requestBody The fields of the agreement to update.
   * @returns The updated agreement data.
   */
  public async updateAgreement(
    agreementId: string,
    requestBody: Agreement,
    config?: AxiosRequestConfig
  ): Promise<{ status?: number; data?: Agreement }> {
    const response = await this.axiosInstance.put(
      `/agreements/${agreementId}`,
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Logically delete an agreement.
   * A logically deleted record will behave as if it does not exist.
   * @param agreementId The ID of the agreement to delete.
   * @param params Query parameters.
   * @param params.version The version number for optimistic locking.
   * @returns Status of the deletion.
   */
  public async deleteAgreement(
    agreementId: string,
    params: { version: number },
    config?: AxiosRequestConfig
  ): Promise<{ status?: number }> {
    const response = await this.axiosInstance.delete(
      `/agreements/${agreementId}`,
      { ...config, params }
    );
    return response.data;
  }

  /**
   * Cancel or terminate an agreement.
   * This action stamps the cancellationDate on the specified agreement.
   * @param agreementId The ID of the agreement to cancel.
   * @param requestBody Request body containing cancellation date and version.
   * @returns The updated agreement details.
   */
  public async cancelAgreement(
    agreementId: string,
    requestBody: { cancellationDate?: string; version: number },
    config?: AxiosRequestConfig
  ): Promise<Agreement> {
    const response = await this.axiosInstance.put(
      `/agreements/${agreementId}/cancel`,
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Renew an agreement.
   * Cancels the specified agreement and creates a new one.
   * @param agreementId The ID of the agreement to renew.
   * @param requestBody The new agreement data.
   * @returns The newly created agreement after renewal.
   */
  public async renewAgreement(
    agreementId: string,
    requestBody: Agreement,
    config?: AxiosRequestConfig
  ): Promise<Agreement> {
    const response = await this.axiosInstance.post(
      `/agreements/${agreementId}/renew`,
      requestBody,
      config
    );
    return response.data;
  }

  //==============================================================================
  //== Agreement Types Service
  //==============================================================================

  /**
   * Register an agreement type.
   * @param requestBody The agreement type to register.
   */
  public async createAgreementType(
    requestBody: Partial<AgreementType>,
    config?: AxiosRequestConfig
  ): Promise<AgreementType> {
    const response = await this.axiosInstance.post(
      "/agreements/types",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Find agreement types by criteria.
   * @param params Query parameters.
   * @param params.code The typeCode to search for (exact match).
   */
  public async findAgreementTypes(
    params: { code: string },
    config?: AxiosRequestConfig
  ): Promise<{ records?: AgreementType[] }> {
    const response = await this.axiosInstance.get("/agreements/types/find", {
      ...config,
      params,
    });
    return response.data;
  }

  /**
   * Get a specific agreement type by its ID.
   * @param agreementTypeId The UUID of the agreement type.
   */
  public async getAgreementType(
    agreementTypeId: string,
    config?: AxiosRequestConfig
  ): Promise<AgreementType> {
    const response = await this.axiosInstance.get(
      `/agreements/types/${agreementTypeId}`,
      config
    );
    return response.data;
  }

  /**
   * Update an agreement type.
   * @param agreementTypeId The UUID of the agreement type to update.
   * @param requestBody The data to update.
   */
  public async updateAgreementType(
    agreementTypeId: string,
    requestBody: Partial<AgreementType>,
    config?: AxiosRequestConfig
  ): Promise<AgreementType> {
    const response = await this.axiosInstance.put(
      `/agreements/types/${agreementTypeId}`,
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Logically delete an agreement type.
   * @param agreementTypeId The UUID of the agreement type to delete.
   */
  public async deleteAgreementType(
    agreementTypeId: string,
    config?: AxiosRequestConfig
  ): Promise<void> {
    await this.axiosInstance.delete(
      `/agreements/types/${agreementTypeId}`,
      config
    );
  }

  //==============================================================================
  //== Invited Users Service
  //==============================================================================

  /**
   * Get a list of invited users.
   * @param params Query parameters.
   * @param params.deleted Include deleted users if set to 1.
   */
  public async getAllInvitedUsers(
    params?: { deleted?: 0 | 1 },
    config?: AxiosRequestConfig
  ): Promise<any> {
    const response = await this.axiosInstance.get("/invited/", {
      ...config,
      params,
    });
    return response.data;
  }

  /**
   * Register an invitation.
   * An invitation email is sent to the invitee. The invitation is valid for one week.
   * @param requestBody Invitation details.
   */
  public async registerInvitation(
    requestBody: {
      unitSetId: string;
      userId: string;
      message?: string;
      assigned: {
        unitId: string;
        jobDutyId: string;
        roleCode: string;
        startDate?: string;
        endDate?: string;
      };
    },
    config?: AxiosRequestConfig
  ): Promise<any> {
    const response = await this.axiosInstance.post(
      "/invited/",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Accept an invitation.
   * @param id The invitation management number (UUID).
   * @param params Query parameters.
   * @param params.nonce Number used once.
   */
  public async acceptInvitation(
    id: string,
    params: { nonce: string },
    config?: AxiosRequestConfig
  ): Promise<void> {
    await this.axiosInstance.get(`/invited/accept/${id}`, {
      ...config,
      params,
    });
  }

  /**
   * Refuse an invitation.
   * @param id The invitation management number (UUID).
   * @param params Query parameters.
   * @param params.nonce Number used once.
   */
  public async refuseInvitation(
    id: string,
    params: { nonce: string },
    config?: AxiosRequestConfig
  ): Promise<void> {
    await this.axiosInstance.get(`/invited/refuse/${id}`, {
      ...config,
      params,
    });
  }

  /**
   * Delete an expired or completed invitation.
   * @param id The invitation ID to delete.
   */
  public async deleteInvitation(
    id: string,
    config?: AxiosRequestConfig
  ): Promise<void> {
    await this.axiosInstance.delete(`/invited/${id}`, config);
  }

  //==============================================================================
  //== Job Duty Service
  //==============================================================================

  /**
   * Create a new Job Duty.
   * `jobDutyCode` must be unique within the unitSet. The effective period must not overlap.
   * @param requestBody The Job Duty to create.
   */
  public async createJobDuty(
    requestBody: JobDuty,
    config?: AxiosRequestConfig
  ): Promise<JobDuty> {
    const response = await this.axiosInstance.post(
      "/job-duties/",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Update a Job Duty.
   * @param id The ID of the Job Duty to update.
   * @param requestBody The updated Job Duty data.
   */
  public async updateJobDuty(
    id: string,
    requestBody: Partial<JobDuty>,
    config?: AxiosRequestConfig
  ): Promise<JobDuty> {
    const response = await this.axiosInstance.put(
      `/job-duties/${id}`,
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Find Job Duties by specified conditions.
   * If no search criteria are provided, it returns a list of all currently effective Job Duties.
   * @param params Query parameters.
   * @param params.code Filter by jobDutyCode.
   * @param params.unitSetId Filter by unitSetId (for system admins). Use '_share' for shared duties.
   */
  public async findJobDuty(
    params?: { code?: string; unitSetId?: string },
    config?: AxiosRequestConfig
  ): Promise<{ status?: number; data?: JobDuty[] }> {
    const response = await this.axiosInstance.get("/job-duties/find", {
      ...config,
      params,
    });
    return response.data;
  }

  //==============================================================================
  //== Role Service
  //==============================================================================

  /**
   * Get a role by its code.
   * @param roleCode The code of the role to retrieve.
   */
  public async getRole(
    roleCode: string,
    config?: AxiosRequestConfig
  ): Promise<{ data: { role: Role; roleCodeList: string[] } }> {
    const response = await this.axiosInstance.get(`/roles/${roleCode}`, config);
    return response.data;
  }

  /**
   * Create or update a role.
   * If the roleCode exists, it updates the role. If it's logically deleted, it restores and updates it.
   * @param roleCode The code of the role to create/update.
   * @param requestBody The role data.
   */
  public async putRole(
    roleCode: string,
    requestBody: Partial<Role>,
    config?: AxiosRequestConfig
  ): Promise<any> {
    const response = await this.axiosInstance.put(
      `/roles/${roleCode}`,
      requestBody,
      config
    );
    return response.data;
  }

  //==============================================================================
  //== Role Set Service
  //==============================================================================

  /**
   * Create a new Role Set.
   * @param requestBody The Role Set data to create.
   */
  public async createRoleSet(
    requestBody: Partial<RoleSet>,
    config?: AxiosRequestConfig
  ): Promise<{ data: { roleSet: RoleSet } }> {
    const response = await this.axiosInstance.post(
      "/role-sets/",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Get a Role Set by its ID.
   * @param roleSetId The ID of the Role Set to retrieve.
   */
  public async getRoleSet(
    roleSetId: string,
    config?: AxiosRequestConfig
  ): Promise<{ data: RoleSet }> {
    const response = await this.axiosInstance.get(
      `/role-sets/${roleSetId}`,
      config
    );
    return response.data;
  }

  /**
   * Update a Role Set.
   * @param roleSetId The ID of the Role Set to update.
   * @param requestBody The Role Set data to update.
   */
  public async updateRoleSet(
    roleSetId: string,
    requestBody: Partial<RoleSet>,
    config?: AxiosRequestConfig
  ): Promise<{ data: { roleSet: RoleSet } }> {
    const response = await this.axiosInstance.put(
      `/role-sets/${roleSetId}`,
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Logically delete a Role Set.
   * @param roleSetId The ID of the Role Set to delete.
   */
  public async deleteRoleSet(
    roleSetId: string,
    config?: AxiosRequestConfig
  ): Promise<any> {
    const response = await this.axiosInstance.delete(
      `/role-sets/${roleSetId}`,
      config
    );
    return response.data;
  }

  //==============================================================================
  //== Other Business Services
  //==============================================================================

  /**
   * Retrieves a list of users belonging to the specified scope.
   * This is a business-purpose API to recursively fetch users.
   * @param requestBody An array of scope conditions to search for users.
   */
  public async listBusinessPartyUsers(
    requestBody: ListBusinessPartyUsersScope[],
    config?: AxiosRequestConfig
  ): Promise<{ data?: ListBusinessPartyUsersResponse }> {
    const response = await this.axiosInstance.post(
      "/listBusinessPartyUsers",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Retrieves a list of users belonging to the specified scope, returned as a tree structure.
   * (agreementType -> unit -> user)
   * @param requestBody Search conditions and limits.
   */
  public async listBusinessPartners(
    requestBody: ListBusinessPartnersBody,
    config?: AxiosRequestConfig
  ): Promise<{ data?: ListBusinessPartnersResponse }> {
    const response = await this.axiosInstance.post(
      "/list-business-partners",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Batch fetch users and units by their IDs.
   * @param requestBody An object containing arrays of userIds and/or unitIds.
   */
  public async getObjectsById(
    requestBody: GetObjectsByIdBody,
    config?: AxiosRequestConfig
  ): Promise<{ data?: GetObjectsByIdResponse }> {
    const response = await this.axiosInstance.post(
      "/get-objects-by-id",
      requestBody,
      config
    );
    return response.data;
  }

  /**
   * Batch fetch users and units by their codes, paired with a unitSetCode.
   * @param requestBody An object containing arrays of userCodes and/or unitCodes.
   */
  public async getObjectsByCode(
    requestBody: any,
    config?: AxiosRequestConfig
  ): Promise<any> {
    const response = await this.axiosInstance.post(
      "/get-objects-by-code",
      requestBody,
      config
    );
    return response.data;
  }
}
